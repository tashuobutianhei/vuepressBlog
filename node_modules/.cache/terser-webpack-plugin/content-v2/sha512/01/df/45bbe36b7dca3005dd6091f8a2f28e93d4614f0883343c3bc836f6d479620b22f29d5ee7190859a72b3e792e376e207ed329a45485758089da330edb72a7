{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{173:function(t,s,a){\"use strict\";a.r(s);var _=a(0),e=Object(_.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var t=this,s=t.$createElement,a=t._self._c||s;return a(\"div\",{staticClass:\"content\"},[a(\"p\",[t._v(\"不谈cdn的前端部署，应该没有什么好谈的，买一个云服务器，前端代码写好后，打包好后直接拖到机器上就可以了，当然这样也是有很多可以优化的点(先不提)。记录一下有cdn，多服务器的情况下时怎么部署的吧。\")]),t._v(\" \"),a(\"h4\",{attrs:{id:\"静态文件和非静态文件\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#静态文件和非静态文件\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" 静态文件和非静态文件\")]),t._v(\" \"),a(\"p\",[t._v(\"静态资源：就是前端的文件，可能是一个index.html，然后引入一堆打包好后的js,css,public之类的东西，也可以是一个前端启的服务，总之是前端自身控制的，不依赖后端生成的前端资源。\")]),t._v(\" \"),a(\"p\",[t._v(\"非静态资源：是后端通过jsp或者模版拼接出的模板，或者是SSR出来的前端文件，这就是非静态资源。\")]),t._v(\" \"),a(\"p\",[t._v(\"独立的静态文件：和静态资源不同的是功能，这个部分可能是图片，可能是vue，react打包好后的js文件，可能是为css文件来自不同的cdn服务，存储加速嘛。\")]),t._v(\" \"),a(\"h4\",{attrs:{id:\"为什么要区分静态和非静态\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#为什么要区分静态和非静态\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" 为什么要区分静态和非静态\")]),t._v(\" \"),a(\"p\",[t._v(\"如果是非静态资源就是由后端去拼接，这种部署只需要对后端服务部署，然后拉取cdn需要的静态文件即可。所以对于部署上在于后端服务的部署，我就不说了，我也不会呀。\")]),t._v(\" \"),a(\"h4\",{attrs:{id:\"前端部署：\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#前端部署：\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" 前端部署：\")]),t._v(\" \"),a(\"p\",[t._v(\"简单来说就是基于随机字符串的非覆盖式部署。好吧有点绕，分开说吧。\")]),t._v(\" \"),a(\"h5\",{attrs:{id:\"_1-随机字符串：md5或者其他方式生产一个字符串（版本号）\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_1-随机字符串：md5或者其他方式生产一个字符串（版本号）\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" 1. 随机字符串：md5或者其他方式生产一个字符串（版本号）\")]),t._v(\" \"),a(\"p\",[t._v(\"对于一分前端文件，由html，js，css三部分构成，但是每次都请求一次js,css就很花费时间，我们这时候要选择的就是缓存js，css这些静态文件，这样就不用每次都去请求了。但是事实不是这样简单的，因为我们的静态文件是会改的呀，那么我们如何在我们更新的时候去更新缓存地址呐？\")]),t._v(\" \"),a(\"p\",[t._v(\"这就出现了版本号的问题，我们只要给没有静态文件一个版本就好了，当我们更新了静态文件后，更新版本，在html也更换相应的版本就好了。那和随机数有什么关系呐？我们如果使用     v_1,v_1.1,v_1.2这样的版本就会有一个问题，我们的js版本可能改的比较频繁，一下子十几个版本就过去了，但是css可能写好页面后就不动了，这样子版本管理就很乱了，所以这时候就用我们的随机数了，我们放弃版本管理，使用随机数，没次修改完都用随机数生成一个所谓的版本号，这就好了。\")]),t._v(\" \"),a(\"h5\",{attrs:{id:\"_2-非覆盖式部署\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_2-非覆盖式部署\",\"aria-hidden\":\"true\"}},[t._v(\"#\")]),t._v(\" 2. 非覆盖式部署\")]),t._v(\" \"),a(\"p\",[t._v(\"要说非覆盖部署就得有覆盖部署，然后对比的结果就是使用非覆盖部署，所以先说一下\"),a(\"em\",[t._v(\"覆盖式部署\")]),t._v(\"吧。\")]),t._v(\" \"),a(\"p\",[t._v(\"试想一下在公司业务中一般不会是一台机器，一台cdn服务的，一般都是多台机器，使用负载均衡进行分布式部署。部署的时候，每一次的升级，都会把我们的前端html放在我们的实例服务上，而把静态资源放在cdn上。\\n这样就会在发布的时候出现一个问题，有多台机器假设有n台，我们采用覆盖式发布就是将新的资源覆盖旧的资源，可是这个覆盖以后会怎么样。因为我们的服务在多台机器上，就总会因为时间的差别，导致有机器的html找不到旧的静态资源，而导致挂站，虽然这个时间间隔很短但是对于项目来说，挂一个和挂多个是没区别的。所以就引出 \"),a(\"em\",[t._v(\"非覆盖式部署\")])]),t._v(\" \"),a(\"p\",[t._v(\"非覆盖式部署的意思就是：当我发布一个新的静态文件的时候，不影响之前的静态文件，两者并存，这个那些引用着原先的静态文件的服务也不会挂掉，当这些服务都更新好后自然引入的都是新的静态文件了。\")])])}],!1,null,null,null);s.default=e.exports}}]);","extractedComments":[]}