## 网络模型

### 1.分层方式
网络模型分为：**OSI七层模型**、**五层模型**、**TCP/IP四层模型**


![99a747d63b0808f8f955b35bbfaa1e3f.png](en-resource://database/1398:1)

![ef9001129644a309ce3e7b0c4efcdbac.png](en-resource://database/1399:1)

#### 1.1 OSI七层模型

**OSI七层协议模型主要是：**
> 应用层（Application）                 <———（第七层）
> 表示层（Presentation）
> 会话层（Session）
> 传输层（Transport）
> 网络层（Network）
> 数据链路层（Data Link）
> 物理层（Physical）                     <———（第一层）


**OSI分层的优点：**
（1）人们可以很容易的讨论和学习协议的规范细节。 
（2）层间的标准接口方便了工程模块化。 
（3）创建了一个更好的互连环境。 
（4）降低了复杂度，使程序更容易修改，产品开发的速度更快。 
（5）每层利用紧邻的下层服务，更容易记住个层的功能。

#### 1.2 TCP/IP 四层模型

TCP/IP是一个**四层**的**体系结构**
主要包括：应用层、运输层、网际层和网络接口层。
从实质上讲，只有上边三层，网络接口层没有什么具体的内容。
![5d3ba9a9d63206ee12aafcd7d00dbfdb.png](en-resource://database/1396:1)


#### 1.3 五层体系结构


五层体系结构包括：应用层、运输层、网络层、数据链路层和物理层。 


五层协议只是OSI和TCP/IP的综合，实际应用还是TCP/IP的四层结构。为了方便可以把下两层称为网络接口层。


## 各层的作用

### 1. 物理层 
电脑要组网，首先就是要把电脑连起来，可以用 **光缆、电缆、双绞线、无线电波** 等方式。
![95e3e0e33bd5e99bc449dffa573d4406.png](en-resource://database/1406:1)

这一层主要定义**物理设备**标准，如**网线的接口类型、光纤的接口类型、各种传输介质的传输速率**等。
   
它的主要作用是 **传输比特流** （就是由1、0转化为电流强弱来进行传输,到达目的地后在转化为1、0，也就是我们常说的 **数模转换** 与 **模数转换**）。
   
这一层的数据叫做 **比特。** 　　
    
### 2. 数据链路层
   单纯的0和1没有任何意义，所以我们要规定解读方式：多少个信号算一组？每个信号位有什么意义？
   
   这就是“数据链路层“的功能，定义了如何让 **格式化数据** 以进行传输，以及如何让控制 **对物理介质的访问**。
   这一层通常还提供 **错误检测和纠正** ，以确保数据的可靠传输。

#### 2.1 以太网协议 （数据的格式是怎么样规定的？）
"以太网"（Ethernet）的协议，规定了**电信号分组方式**。
**以太网规定**：一组电信号构成一个数据包，叫做"**帧**"（Frame）。每一帧分成两个部分：**标头（Head）** 和 **数据（Data）**
![a2378014df3f7f9f9ac3d7dc00593bce.png](en-resource://database/1407:1)

    
**标头**：包含数据包的一些说明项，比如**发送者（源物理地址）**、**接受者（目的物理地址）**、**数据类型**、**CRC校验码**等等。
**数据**：则是数据包的具体内容。

具体的帧结构如下图所示：
![22c25ed4ef2d844f51ca73a5993ba574.png](en-resource://database/1401:1)


"标头"的长度，固定为18（6+6+2+4）字节。
"数据"的长度，最短为46字节，最长为1500字节。
因此，整个"帧"最短为64字节，最长为1518字节。如果数据很长，就必须分割成多个帧进行发送。

#### 2.2 MAC 地址（用什么标识？）
以太网协议中的标头包含一些说明项，如：发送者、接收者、数据类型等。
那么他是怎么标识的呢？

以太网规定，连入网络的所有设备，都必须具有 "**网卡**" 接口。
**数据包**必须是**从一块网卡**，**传送到另一块网卡**。
**网卡的地址**，就是**数据包**的**发送地址**和**接收地址**，这叫做**MAC地址**。
**每块网卡**出厂的时候，都有一个全世界**独一无二的MAC地址**，长度是48个二进制位，通常用12个十六进制数表示。
![641279c07aaa53ed8e3ac91423194ff0.png](en-resource://database/1405:1)

前6个十六进制数是厂商编号，后6个是该厂商的网卡流水号。有了MAC地址，就可以定位网卡和数据包的路径了。

#### 2.3 ARP协议（怎么找到对方的标识？）

一块网卡怎么会知道另一块网卡的MAC地址？
**ARP协议（地址解析协议）** 可以解决这个问题。

ARP协议将 **IP 地址转化为 MAC 物理地址**。
在A不知道B的MAC地址的情况下，A就发送一个 **ARP request**，这个 request 是一个没有指定目的地的广播， **广播一个ARP请求包** ，
请求包中填有B的IP(192.168.1.2)，以太网中的所有计算机都会接收这个请求，
而正常的情况下只有B会给出ARP应答包，包中就填充上了B的MAC地址，并回复给A一个 **ARP reply**，
ARP reply是有明确目标地址的，是**单播**。     
A得到ARP应答后，将B的MAC地址放入本机缓存，便于下次使用。     
本机MAC缓存是有生存期的，生存期结束后，将再次重复上面的过程。

#### 2.4 广播 （怎么把数据发出去？）

有了MAC地址后，系统怎样才能把数据包准确送到接收方？
以太网采用了一种很"原始"的方式，它不是把数据包准确送到接收方，而是**向本网络内所有计算机发送**，让每台计算机自己**判断，是否为接收方**。

上面获取 MAC 地址的时候也提到了广播。什么是广播？
广播：网络广播是指**一个节点同时向相同域中的其它所有节点传输数据包**的过程。
![6241fd8e3f60697d656c18d754e9187c.png](en-resource://database/1404:1)

1号计算机向2号计算机发送一个数据包，同一个子网络的3号、4号、5号计算机都会收到这个包。它们读取这个包的"标头"，找到接收方的MAC地址，然后与自身的MAC地址相比较，如果两者相同，就接受这个包，做进一步处理，否则就丢弃这个包。这种发送方式就叫做"广播"（broadcasting）。

有了数据包的定义、网卡的MAC地址、广播的发送方式，"链接层"就可以在多台计算机之间传送数据了。
### 3. 网络层
 #### 3.0 什么是网络层 （我要和别的地区的人网上冲浪！）
 在位于 **不同地理位置** 的网络中的 **两个主机系统** 之间提供 **连接** 和 **路径选择** 。
 Internet的发展使得从世界各站点访问信息的用户数大大增加，而网络层正是管理这种连接的层。
 
 ---
以太网协议，依靠MAC地址发送数据。理论上，单单依靠MAC地址，上海的网卡就可以找到洛杉矶的网卡了，技术上是可以实现的。

但是以太网采用广播方式发送数据包，所有成员**人手一"包"，效率很低**。
而且 **并不是所有的网卡都是在同一个子网络** 上的。以太网协议的广播方式，**只能局限在发送者所在的子网络**。
也就是说，如果两台计算机**不在同一个子网络，广播是传不过去的**。
这种设计是合理的，否则互联网上每一台计算机都会收到所有包，那会引起灾难。

因此，必须找到一种方法，能够区分哪些MAC地址属于同一个子网络，哪些不是。如果是同一个子网络，就采用广播方式发送，否则就采用 "**路由**" 方式发送。（ **"路由"的意思，就是指如何向不同的子网络分发数据包** ）**MAC地址** 本身无法做到这一点。**它只与厂商有关，与所处网络无关**。

**这就导致了”网络层”的诞生。它的作用是引进一套新的地址，使得我们能够区分不同的计算机是否属于同一个子网络。这套地址就叫做”网络地址”，简称”网址”。**

"网络层”出现以后，每台计算机有了两种地址，一种是 **MAC地址** ，另一种是 **网络地址** 。
两种地址之间**没有任何联系**，
**MAC地址是绑定在网卡上的，网络地址则是管理员分配的**，它们只是随机组合在一起（因此网址可以变化）。

网络地址帮助我们确定计算机所在的子网络，MAC地址则将数据包送到该子网络中的目标网卡。因此，从逻辑上可以推断，必定是**先处理网络地址，然后再处理MAC地址**。

#### 3.1 IP协议（我的另一个标识，网络地址）

规定 **网络地址的协议** ，叫做 **IP协议**。**它所定义的地址**，就被称为 **IP地址** 。

目前，广泛采用的是IP协议第四版，简称IPv4。这个版本规定，网络地址由32个二进制位组成。
![02fad2d1373264ae030dca74611bc9d6.png](en-resource://database/1400:1)


习惯上，我们用分成四段的十进制数表示IP地址，从0.0.0.0一直到255.255.255.255。

互联网上的每一台计算机，都会分配到一个IP地址。
IP地址分成 **两个部分**：前一部分代表 **网络**，后一部分代表 **主机**。

比如，IP地址172.16.254.1，这是一个32位的地址，假定它的网络部分是前24位（172.16.254），那么主机部分就是后8位（最后的那个1）。

**处于同一个子网络的电脑，它们IP地址的网络部分必定是相同的**，也就是说172.16.254.2应该与172.16.254.1处在同一个子网络。


#### 3.2 子网掩码 （我们是一个子网吗？）

所谓”子网掩码”，就是表示子网络特征的一个参数，用于判断两个 IP 是否处于同一个子网。

它在形式上等同于IP地址，也是一个32位二进制数字，它的 **网络部分全部为1，主机部分全部为0**。

子网编码中网络部分占多少位是不一定的。

比如，IP地址172.16.254.1，如果**已知网络部分是前24位**，**主机部分是后8位**，**那么子网络掩码就是11111111.11111111.11111111.00000000**，写成十进制就是255.255.255.0。

知道”子网掩码”，我们就能判断，任意两个IP地址是否处在同一个子网络。

---

**方法是将两个IP地址与子网掩码分别进行AND运算（两个数位都为1，运算结果为1，否则为0），然后比较结果是否相同**，如果是的话，就表明它们在同一个子网络中，否则就不是。

#### 3.3 IP数据包（把新的数据加进去）


根据IP协议发送的数据，就叫做IP数据包。不难想象，其中必定包括IP地址信息。

以太网数据包只包含MAC地址，并没有IP地址的栏位。

我们可以把**IP数据包直接放进以太网数据包的"数据"部分**，因此完全**不用修改以太网的规格**。
**这就是互联网分层结构的好处：上层的变动完全不涉及下层的结构。**

IP 数据包也分为“标头”和“数据”两个部分：
![4ba64763836369a1346eec05f192ee69.png](en-resource://database/1402:1)


"标头"部分主要包括版本、长度、IP地址等信息，"数据"部分则是IP数据包的具体内容。它放进以太网数据包后，以太网数据包就变成了下面这样。
![56ef8038c5ca9616e07c4d48bf825343.png](en-resource://database/1403:1)


IP数据包的"标头"部分的长度为20到60字节，整个数据包的总长度最大为65,535字节。因此，理论上，一个IP数据包的"数据"部分，最长为65,515字节。前面说过，以太网数据包的"数据"部分，最长只有1500字节。因此，**如果IP数据包超过了1500字节，它就需要分割成几个以太网数据包，分开发送了**。

### 4. 传输层
   定义了一些 **传输数据的协议和端口号**（WWW端口80等），
    如： 
**TCP**（transmission control protocol –传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据） 
**UDP**（user datagram protocol–用户数据报协议，与TCP特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，如QQ聊天数据就是通过这种方式传输的）。 主要是将从下层接收的数据进行分段和传输，到达目的地址后再进行重组。常常把这一层数据叫做段。

#### 4.0 什么是传输层

有了MAC地址和IP地址，我们已经可以在互联网上任意两台主机上建立通信。
但是当我们运行许多程序时，怎么区分发送来的数据是供哪一个进程使用的？
这时候就需要一个新的参数，来表示这个数据包到底供那个进程使用，于是 **“端口”(port)** 出现了。
#### 4.1 端口（哪个程序的数据？）

"端口"（port），它其实是每一个 **使用网卡的程序的编号** 。每个数据包都发到主机的特定端口，所以不同的程序就能取到自己所需要的数据。

"端口"是0到65535之间的一个整数，正好16个二进制位。0到1023的端口被系统占用，用户只能选用大于1023的端口。不管是浏览网页还是在线聊天，应用程序会随机选用一个端口，然后与服务器的相应端口联系。


**"传输层"的功能，就是建立"端口到端口"的通信**。相比之下， **"网络层"的功能是建立"主机到主机"的通信**。
只要确定主机和端口，我们就能实现程序之间的交流。
因此，Unix系统就把主机+端口，叫做"套接字"（socket）。有了它，就可以进行网络应用程序开发了。

#### 4.2 UDP协议

好了我们现在要在数据包中加入端口信息了。
加新信息就需要新的协议了，最简单的实现是UDP协议，他的格式几乎就是在数据前面加上端口号。

UDP数据包，也是由“标头”和“数据”两部分组成。
![fe5640249e4864c8a674b7bf67ca06a0.png](en-resource://database/1411:1)


"**标头**"部分主要定义了发出端口和接收端口，
"**数据**"部分就是具体的内容。

然后，把整个UDP数据包放入IP数据包的"数据"部分，
IP数据包又是放在以太网数据包之中的，所以整个以太网数据包现在变成了下面这样

![31d4c72023151547a5faebec03497dbf.png](en-resource://database/1409:1)


UDP数据包非常简单，"标头"部分一共只有8个字节，总长度不超过65,535字节，正好放进一个IP数据包。

#### 4.3 TCP协议

**UDP协议的优点是比较简单，容易实现，但是缺点是可靠性较差，一旦数据包发出，无法知道对方是否收到。**

为了提高网路的可靠性，TCP协议诞生了，可以近似认为，他就是 **有确认机制的UDP协议**，
每发出一个数据包都要求确认。如果有一个数据包遗失，就收不到确认，发出方就知道有必要重发这个数据包了。

**TCP协议能够确保数据不会遗失。**
**它的缺点是：
过程复杂：（TCP三次握手、四次挥手等）
实现困难：（数据重传机制、流量控制机制等）
消耗较多的资源。**

TCP数据包和UDP数据包一样，都是内嵌在IP数据包的"数据"部分。

### 5. 应用层（会话层、表示层、应用层）

会话层,表示层,应用层构成开放系统的高3层，面对应用进程提供**分布处理、对话管理、信息表示、恢复最后的差错**等。

TCP协议通过端口号，可以为各种各样的程序传递数据，比如Email、WWW、FTP等等。
那么，必须有 **不同协议规定电子邮件、网页、FTP数据的格式** ，这些 **应用程序协议就构成了"应用层"**。 

应用程序收到"传输层"的数据，接下来就要进行解读。

#### 5.1 会话层

通过传输层（端口号：传输端口与接收端口）建立数据传输的通路。
主要在你的系统之间 **发起会话或者接受会话请求**（设备之间需要互相认识可以是 **IP** 也可以是 **MAC** 或者是 **主机名** ）

会话层（Session）提供的服务可**使应用建立和维持会话**，并能**使会话获得同步**。
会话层 **使用校验点使通信会话在通信失效时从校验点继续恢复通信**。这种能力对于传送大的文件极为重要。

#### 5.2 表示层

表示层的作用之一是为 **异种机通信提供一种公共语言，以便能进行互操作**。
这种类型的服务之所以需要，是因为不同的计算机体系结构使用的数据表示法不同。

例如，PC程序与另一台计算机进行通信，其中一台计算机使用扩展二一十进制交换码（EBCDIC），而另一台则使用美国信息交换标准码（ASCII）来表示相同的字符。如有必要，表示层会通过使用一种通格式来 **实现多种数据格式之间的转换**。 　　
#### 5. 3 应用层
是最靠近用户的OSI层。这一层为**用户的应用程序**（例如电子邮件、文件传输和终端仿真）提供网络服务。
应用层包含了我们通常要使用的协议

* HTTP（Hyper Text Transport Protocol）协议：超文本传输协议 ，使用TCP的80端口

* FTP（File Transfer Protocol）文件传输协议

* SMTP（Simple Mail Transfer Protocol）简单邮件传输协议，TCP的25端口，用户发邮件

* POP3（Post Office Protocol Version 3）邮局协议版本3，TCP的110号端口，用于收邮件

* DNS（Domain Name System）域名解析协议。使用TCP和UDP的53号端口，作用是把WWW的域名解析成IP地址。

### 访问网页发生了什么？

打开浏览器，想要访问Google，在地址栏输入了网址：www.google.com。
这意味着，浏览器要向Google发送一个网页请求的数据包。
网上冲浪开始了。

#### DNS协议（把域名变成IP地址）

其实访问页面可以有两种方式 IP 和 域名， DNS服务器就可以把域名转换为IP地址。

我们知道，发送数据包，必须要知道对方的IP地址。但是，现在，我们只知道网址www.google.com，不知道它的IP地址。

DNS协议可以帮助我们，将这个网址转换成IP地址。

DNS域名解析时用的是UDP协议。

已知DNS服务器为8.8.8.8，于是我们向这个地址发送一个DNS数据包（53端口）。
然后，DNS服务器做出响应，告诉我们Google的IP地址是172.194.72.105。于是，我们知道了对方的IP地址。

#### 应用层协议

浏览网页用的是HTTP协议，它的整个数据包构造是这样的：
![276d68c65ec9c20ce92a98ee4267036a.png](en-resource://database/1408:1)


HTTP部分的内容，类似于下面这样：
```
　GET / HTTP/1.1　　
   Host: www.google.com
   Connection: keep-alive
   User-Agent: Mozilla/5.0 (Windows NT 6.1) ......
   Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
   Accept-Encoding: gzip,deflate,sdch
   Accept-Language: zh-CN,zh;q=0.8
   Accept-Charset: GBK,utf-8;q=0.7,*;q=0.3
   Cookie: ... ...
```
我们假定这个部分的长度为4960字节，它会被嵌在TCP数据包之中。
#### TCP协议

TCP数据包需要设置端口，接收方（Google）的HTTP端口默认是80，发送方（本机）的端口是一个随机生成的1024-65535之间的整数，假定为51775。

TCP数据包的标头长度为20字节，加上嵌入HTTP的数据包，总长度变为4980字节。
#### IP协议

然后，TCP数据包再嵌入IP数据包。IP数据包需要设置双方的IP地址，这是已知的，发送方是192.168.1.100（本机），接收方是172.194.72.105（Google）。IP数据包的标头长度为20字节，加上嵌入的TCP数据包，总长度变为5000字节。
#### 以太网协议

最后，IP数据包嵌入以太网数据包。以太网数据包需要设置双方的MAC地址，发送方为本机的网卡MAC地址，接收方为网关192.168.1.1的MAC地址（通过 **ARP协议** 得到）。

以太网数据包的数据部分，最大长度为1500字节，而现在的IP数据包长度为5000字节。因此，IP数据包必须分割成四个包。因为每个包都有自己的IP标头（20字节），所以四个包的IP数据包的长度分别为1500、1500、1500、560。
![d221c428f2a3270263a73b3d641d2079.png](en-resource://database/1410:1)

#### 服务器响应
经过多个网关的转发，Google的服务器172.194.72.105，收到了这四个以太网数据包。

根据IP标头的序号，Google将四个包拼起来，取出完整的TCP数据包，然后读出里面的"HTTP请求"，接着做出"HTTP响应"，再用TCP协议发回来。

本机收到HTTP响应以后，就可以将网页显示出来，完成一次网络通信。


